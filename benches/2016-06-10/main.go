//  Copyright 2016 Walter Schulze
//
//  Licensed under the Apache License, Version 2.0 (the "License");
//  you may not use this file except in compliance with the License.
//  You may obtain a copy of the License at
//
//    http://www.apache.org/licenses/LICENSE-2.0
//
//  Unless required by applicable law or agreed to in writing, software
//  distributed under the License is distributed on an "AS IS" BASIS,
//  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//  See the License for the specific language governing permissions and
//  limitations under the License.

package main

import (
	"fmt"
	"golang.org/x/tools/benchmark/parse"
	"io"
	"io/ioutil"
	"os"
	"os/exec"
	"strconv"
	"strings"
	"text/template"
)

func newMemCmd(num int) *exec.Cmd {
	return exec.Command("go", "test", "-v", "-run=XXXX", "-bench=.", "github.com/katydid/katydid/validator-gogo-proto/testsuite/mem", "-args", fmt.Sprintf("-b.N=%d", num))
}

func newAutoCmd() *exec.Cmd {
	return exec.Command("go", "test", "-v", "-run=XXXX", "-bench=.", "github.com/katydid/katydid/validator-gogo-proto/testsuite/auto")
}

type benchRunner struct {
	Name   string
	cmd    *exec.Cmd
	output []float64
}

func (b *benchRunner) run() error {
	stderrPipe, err := b.cmd.StderrPipe()
	if err != nil {
		return err
	}
	stderrReader := io.TeeReader(stderrPipe, os.Stderr)
	stdoutPipe, err := b.cmd.StdoutPipe()
	if err != nil {
		return err
	}
	stdoutReader := io.TeeReader(stdoutPipe, os.Stderr)
	reader := io.MultiReader(stdoutReader, stderrReader)
	if err := b.cmd.Start(); err != nil {
		return err
	}
	out, err := ioutil.ReadAll(reader)
	if err != nil {
		return err
	}
	err = b.cmd.Wait()
	if err != nil {
		return err
	}
	outs := strings.Split(string(out), "\n")
	b.output = make([]float64, len(benchmarks))
	for _, s := range outs {
		if !strings.HasPrefix(s, "Benchmark") {
			continue
		}
		res, err := parse.ParseLine(s)
		if err != nil {
			return err
		}
		name := strings.Split(res.Name, "-")[0]
		for i, benchmark := range benchmarks {
			if benchmark.name == name {
				b.output[i] = res.NsPerOp
			}
		}
	}
	fmt.Fprintf(os.Stderr, "%#v\n", b.output)
	return nil
}

func (b *benchRunner) String() string {
	return traceValue(b.Name, b.output)
}

func traceValue(name string, vals []float64) string {
	xs := make([]string, len(vals))
	ys := make([]string, len(vals))
	for i, v := range vals {
		xs[i] = fmt.Sprintf("%d", i)
		ys[i] = fmt.Sprintf("%f", v)
	}
	return fmt.Sprintf("{\n\tx: [%s],\n\ty: [%s],\n\ttype: 'bar',\n\tname: '%s'\n}", strings.Join(xs, ", "), strings.Join(ys, ", "), name)
}

func tickVals() string {
	vals := make([]string, len(benchmarks))
	for i := range vals {
		vals[i] = fmt.Sprintf("%d", i)
	}
	return "[" + strings.Join(vals, ", ") + "]"
}

func tickNames() string {
	vals := make([]string, len(benchmarks))
	for i, benchmark := range benchmarks {
		vals[i] = strconv.Quote(benchmark.expr)
	}
	return "[" + strings.Join(vals, ", ") + "]"
}

var templ = `
<!-- generated by github.com/katydid/katydid.github.io/bench/main.go -->

<html>
<head>
  <script src="https://cdn.plot.ly/plotly-latest.min.js"></script>
</head>

<body>
  <div id="myPlot"></div>
  <div>
  <center>
  <table>
  	<tr><td>mem10</td><td>:</td><td>The memoized implementation of validator running 10 iterations.</td></tr>
  	<tr><td>mem100</td><td>:</td><td>The memoized implementation of validator running 100 iterations.</td></tr>
  	<tr><td>mem1000</td><td>:</td><td>The memoized implementation of validator running 1000 iterations.</td></tr>
  	<tr><td>auto</td><td>:</td><td>The compiled implementation of validator.  <br/>Beware of the compilation time, which is not accounted for in this benchmark.</td></tr>
  </table>
  </center>
  </div>
  <script>
  	{{range $index, $trace := .}}
    var trace{{$index}} = {{$trace}};
	{{end}}
	
	var data = [ {{range $index, $trace := .}}trace{{$index}},{{end}} ];

	var layout = { 
	  xaxis: {
    	autorange: true,
    	ticktext: {{tickNames}},
    	tickvals: {{tickVals}}
	  },
	  yaxis: {
	  	title: 'ns/op',
	    autorange: true
	  },
	  title:'Memoized vs Compiled Benchmarks',
	  barmode: 'group',
	  margin: {
	  	b: 200
	  },
	  height: 1000
	};

	Plotly.newPlot('myPlot', data, layout);
  </script>
</body>
</html>
`

type benchmark struct {
	name string
	expr string
}

var benchmarks = []benchmark{
	{name: "BenchmarkProtoNumAndNameTelephoneProtoNum", expr: `(.Name == "David" & .Telephone == "0123456789")`},
	{name: "BenchmarkProtoNumContextPersonProtoNum", expr: `.Addresses:_[Number == 456, Street == "TheStreet"]`},
	{name: "BenchmarkProtoNumCorrectNotNameProtoNum", expr: `(@name|@nil) #nil=!(.Name:*) #name=.Name!="David"`},
	{name: "BenchmarkProtoNumEmptyOrNilProtoNum", expr: `(@empty|@nil) #empty=.Name->eq(length($string),0) #nil=!(.Name:*)`},
	{name: "BenchmarkProtoNumIncorrectNotNameProtoNum", expr: `.Name != "David"`},
	{name: "BenchmarkProtoNumLenNameProtoNum", expr: `.Name:->eq(length($string),0)`},
	{name: "BenchmarkProtoNumNilNameProtoNum", expr: `!(.Name:*)`},
	{name: "BenchmarkProtoNumOrNameTelephoneProtoNum", expr: `( .Name == "David" | .Telephone == "0123456789")`},
	{name: "BenchmarkProtoNumListIndexAddressProtoNum", expr: `.Addresses[*,_:.Number:== 2,_:.Number:== 1]`},

	{name: "BenchmarkProtoNumRecursiveSrcTreeProtoNum", expr: `([PackageName:== "io",*]|[*,Imports._:@main])`},

	{name: "BenchmarkProtoNumTypewriterPrisonDaisySledProtoNum", expr: `.PocketRoses.DaisySled == 1`},
	{name: "BenchmarkProtoNumTypewriterPrisonMapSharkProtoNum", expr: `.PocketRoses.MapShark *= "a"`},
	{name: "BenchmarkProtoNumTypewriterPrisonMenuPaperclipProtoNum", expr: `.PocketRoses.MenuPaperclip: [ _ *= "a", *]`},
	{name: "BenchmarkProtoNumTypewriterPrisonScarBusStopProtoNum", expr: `.PocketRoses.ScarBusStop *= "a"`},
	{name: "BenchmarkProtoNumTypewriterPrisonSmileLetterProtoNum", expr: `.PocketRoses.SmileLetter::$bool`},

	{name: "BenchmarkProtoNumBridgePepperProtoNum", expr: `.FinanceJudo.SaladWorry.SpyCarpenter.BridgePepper:_ *= "a"`},
	{name: "BenchmarkProtoNumBridgePepperAndFountainTargetProtoNum", expr: `.F*o...S*r:(.B*r:_*="a" & .FountainTarget:_*="a")`},
}

func main() {
	benches := []*benchRunner{
		&benchRunner{Name: "mem10", cmd: newMemCmd(10)},
		&benchRunner{Name: "mem100", cmd: newMemCmd(100)},
		&benchRunner{Name: "mem1000", cmd: newMemCmd(1000)},
		&benchRunner{Name: "auto", cmd: newAutoCmd()},
	}
	for _, b := range benches {
		err := b.run()
		if err != nil {
			fmt.Fprintf(os.Stderr, "%v\n", err)
			os.Exit(1)
		}
	}
	tmpl := template.Must(template.New("a").Funcs(map[string]interface{}{
		"tickVals":  tickVals,
		"tickNames": tickNames,
	}).Parse(templ))
	if err := tmpl.Execute(os.Stdout, benches); err != nil {
		panic(err)
	}
}
